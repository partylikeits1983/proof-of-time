{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":18036114417134279181,"abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"timestamp","type":{"kind":"field"},"visibility":"public"},{"name":"leaf","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"31":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"32":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"33":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::hash::Hasher;\nuse crate::default::Default;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"70":{"source":"use dep::std::hash::poseidon;\n\nfn main(secret: Field, nullifier: Field, timestamp: pub Field, leaf: pub Field) {\n    let hash_0 = poseidon::bn254::hash_2([secret, nullifier]);\n    let _leaf = poseidon::bn254::hash_2([hash_0, timestamp]);\n\n    // assert proposed leaf matches certain constraints\n    assert(_leaf == leaf);\n}\n\n#[test]\nfn test_main() {\n    let secret = 0;\n    let nullifier = 0;\n    let timestamp = 1731753946; // Sat Nov 16 2024 04:54:06 GMT+0000\n\n    let hash_0 = poseidon::bn254::hash_2([secret, nullifier]);\n    let _leaf = poseidon::bn254::hash_2([hash_0, timestamp]);\n\n    println(_leaf);\n    \n    main(secret, nullifier, timestamp, _leaf);\n\n    let nulifier_hash = poseidon::bn254::hash_1([nullifier]);\n    println(nulifier_hash);\n\n}\n\n","path":"/Users/partylikeits1983/Desktop/proof-of-time/circuits/create_event/src/main.nr"}},"names":["main"],"brillig_names":[]}